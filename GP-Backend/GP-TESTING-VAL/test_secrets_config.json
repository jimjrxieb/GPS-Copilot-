{
  "vault": {
    "provider": "hashicorp_vault",
    "project": "Portfolio",
    "environment": "production",
    "timestamp": "2025-09-21T21:13:00.346816",
    "configuration": {
      "vault_address": "https://vault.Portfolio.internal:8200",
      "namespace": "Portfolio-production",
      "auth_method": "kubernetes",
      "policies": [
        {
          "name": "Portfolio-production-read",
          "description": "Read-only access to application secrets",
          "rules": "\npath \"secret/data/Portfolio/production/*\" {\n  capabilities = [\"read\", \"list\"]\n}\n\npath \"secret/metadata/Portfolio/production/*\" {\n  capabilities = [\"read\", \"list\"]\n}\n"
        },
        {
          "name": "Portfolio-production-write",
          "description": "Write access for CI/CD pipelines",
          "rules": "\npath \"secret/data/Portfolio/production/*\" {\n  capabilities = [\"create\", \"update\", \"delete\", \"read\", \"list\"]\n}\n\npath \"secret/metadata/Portfolio/production/*\" {\n  capabilities = [\"read\", \"list\", \"delete\"]\n}\n"
        },
        {
          "name": "Portfolio-production-rotation",
          "description": "Policy for automated secret rotation",
          "rules": "\npath \"auth/token/renew-self\" {\n  capabilities = [\"update\"]\n}\n\npath \"secret/data/Portfolio/production/rotation/*\" {\n  capabilities = [\"create\", \"update\", \"read\"]\n}\n"
        }
      ],
      "secrets_engines": [
        {
          "type": "kv-v2",
          "path": "secret/Portfolio",
          "description": "KV v2 secrets engine for application secrets",
          "options": {
            "version": "2",
            "max_versions": 10,
            "cas_required": false,
            "delete_version_after": "30d"
          }
        },
        {
          "type": "database",
          "path": "database/Portfolio",
          "description": "Dynamic database credentials",
          "config": {
            "plugin_name": "postgresql-database-plugin",
            "connection_url": "{{protocol}}://{{username}}:{{password}}@{{hosts}}/{{database}}",
            "allowed_roles": [
              "readonly",
              "readwrite",
              "admin"
            ],
            "max_open_connections": 5,
            "max_connection_lifetime": "5m"
          }
        },
        {
          "type": "pki",
          "path": "pki/Portfolio",
          "description": "PKI engine for TLS certificate management",
          "config": {
            "max_lease_ttl": "8760h",
            "default_lease_ttl": "720h"
          }
        }
      ],
      "audit": {
        "file": {
          "type": "file",
          "path": "/vault/logs/audit.log",
          "description": "File-based audit logging",
          "options": {
            "format": "json",
            "hmac_accessor": true,
            "log_raw": false
          }
        },
        "syslog": {
          "type": "syslog",
          "description": "Syslog audit backend for SIEM integration",
          "options": {
            "facility": "AUTH",
            "tag": "vault",
            "format": "json"
          }
        }
      }
    },
    "terraform_config": "\n# HashiCorp Vault Configuration for Portfolio\n# Generated by James-OS GuidePoint Security Platform\n\nterraform {\n  required_providers {\n    vault = {\n      source  = \"hashicorp/vault\"\n      version = \"~> 3.0\"\n    }\n  }\n}\n\nprovider \"vault\" {\n  address = \"https://vault.Portfolio.internal:8200\"\n  namespace = \"Portfolio-production\"\n}\n\n# Enable KV v2 secrets engine\nresource \"vault_mount\" \"kvv2\" {\n  path        = \"secret/Portfolio\"\n  type        = \"kv-v2\"\n  description = \"KV v2 secret engine for Portfolio\"\n\n  options = {\n    version = \"2\"\n    max_versions = 10\n  }\n}\n\n# Create policies\nresource \"vault_policy\" \"read_policy\" {\n  name = \"Portfolio-production-read\"\n\n  policy = <<EOT\npath \"secret/data/Portfolio/production/*\" {\n  capabilities = [\"read\", \"list\"]\n}\nEOT\n}\n\nresource \"vault_policy\" \"write_policy\" {\n  name = \"Portfolio-production-write\"\n\n  policy = <<EOT\npath \"secret/data/Portfolio/production/*\" {\n  capabilities = [\"create\", \"update\", \"delete\", \"read\", \"list\"]\n}\nEOT\n}\n\n# Configure Kubernetes auth\nresource \"vault_auth_backend\" \"kubernetes\" {\n  type = \"kubernetes\"\n  path = \"kubernetes\"\n}\n\nresource \"vault_kubernetes_auth_backend_config\" \"k8s_auth\" {\n  backend                = vault_auth_backend.kubernetes.path\n  kubernetes_host        = \"https://kubernetes.default.svc.cluster.local:443\"\n  kubernetes_ca_cert     = file(\"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\")\n  token_reviewer_jwt     = file(\"/var/run/secrets/kubernetes.io/serviceaccount/token\")\n  disable_iss_validation = true\n}\n\n# Create Kubernetes auth role\nresource \"vault_kubernetes_auth_backend_role\" \"app_role\" {\n  backend                          = vault_auth_backend.kubernetes.path\n  role_name                        = \"Portfolio-app\"\n  bound_service_account_names      = [\"Portfolio-sa\"]\n  bound_service_account_namespaces = [\"Portfolio\"]\n  token_ttl                        = 3600\n  token_policies                   = [vault_policy.read_policy.name]\n}\n",
    "kubernetes_integration": {
      "service_account": "\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: Portfolio-sa\n  namespace: Portfolio\n",
      "vault_agent_config": "\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: vault-agent-config\n  namespace: Portfolio\ndata:\n  vault-agent-config.hcl: |\n    exit_after_auth = false\n    pid_file = \"/home/vault/pidfile\"\n\n    auto_auth {\n      method \"kubernetes\" {\n        mount_path = \"auth/kubernetes\"\n        config {\n          role = \"Portfolio-app\"\n        }\n      }\n\n      sink \"file\" {\n        config {\n          path = \"/home/vault/.vault-token\"\n        }\n      }\n    }\n\n    template {\n      source = \"/vault/configs/database.yml.tpl\"\n      destination = \"/vault/secrets/database.yml\"\n    }\n",
      "sidecar_injection": "\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: Portfolio-app\n  namespace: Portfolio\nspec:\n  template:\n    metadata:\n      annotations:\n        vault.hashicorp.com/agent-inject: \"true\"\n        vault.hashicorp.com/role: \"Portfolio-app\"\n        vault.hashicorp.com/agent-inject-secret-database: \"secret/data/Portfolio/database\"\n    spec:\n      serviceAccountName: Portfolio-sa\n      containers:\n      - name: app\n        image: Portfolio:latest\n"
    }
  },
  "aws": {
    "provider": "aws_secrets_manager",
    "project": "Portfolio",
    "region": "us-east-1",
    "timestamp": "2025-09-21T21:13:00.346990",
    "configuration": {
      "secrets": [
        {
          "name": "Portfolio/database/credentials",
          "description": "Database credentials",
          "type": "json",
          "value_template": {
            "username": "{{resolve:secretsmanager:username}}",
            "password": "{{resolve:secretsmanager:password}}",
            "host": "database.internal",
            "port": 5432,
            "database": "Portfolio"
          },
          "tags": {
            "Project": "Portfolio",
            "Type": "database",
            "Rotation": "enabled"
          }
        },
        {
          "name": "Portfolio/api/keys",
          "description": "API keys and tokens",
          "type": "json",
          "value_template": {
            "api_key": "{{resolve:secretsmanager:api_key}}",
            "api_secret": "{{resolve:secretsmanager:api_secret}}",
            "webhook_secret": "{{resolve:secretsmanager:webhook_secret}}"
          },
          "tags": {
            "Project": "Portfolio",
            "Type": "api",
            "Rotation": "enabled"
          }
        },
        {
          "name": "Portfolio/tls/certificates",
          "description": "TLS certificates and keys",
          "type": "json",
          "value_template": {
            "cert": "{{resolve:secretsmanager:cert}}",
            "key": "{{resolve:secretsmanager:key}}",
            "ca": "{{resolve:secretsmanager:ca}}"
          },
          "tags": {
            "Project": "Portfolio",
            "Type": "tls",
            "Rotation": "manual"
          }
        }
      ],
      "iam_policies": {
        "read_policy": {
          "name": "Portfolio-secrets-read",
          "policy": {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "secretsmanager:GetSecretValue",
                  "secretsmanager:DescribeSecret"
                ],
                "Resource": "arn:aws:secretsmanager:*:*:secret:Portfolio/*"
              },
              {
                "Effect": "Allow",
                "Action": "secretsmanager:ListSecrets",
                "Resource": "*",
                "Condition": {
                  "StringEquals": {
                    "secretsmanager:ResourceTag/Project": "Portfolio"
                  }
                }
              }
            ]
          }
        },
        "write_policy": {
          "name": "Portfolio-secrets-write",
          "policy": {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "secretsmanager:GetSecretValue",
                  "secretsmanager:DescribeSecret",
                  "secretsmanager:PutSecretValue",
                  "secretsmanager:UpdateSecret",
                  "secretsmanager:TagResource"
                ],
                "Resource": "arn:aws:secretsmanager:*:*:secret:Portfolio/*"
              }
            ]
          }
        },
        "rotation_policy": {
          "name": "Portfolio-secrets-rotation",
          "policy": {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "secretsmanager:RotateSecret",
                  "secretsmanager:UpdateSecretVersionStage"
                ],
                "Resource": "arn:aws:secretsmanager:*:*:secret:Portfolio/*"
              }
            ]
          }
        }
      },
      "rotation": {
        "lambda_function": "\nimport json\nimport boto3\nimport os\n\ndef lambda_handler(event, context):\n    '''\n    Automatic rotation handler for Portfolio secrets\n    '''\n    service_client = boto3.client('secretsmanager')\n    arn = event['SecretId']\n    token = event['Token']\n    step = event['Step']\n\n    if step == \"createSecret\":\n        create_secret(service_client, arn, token)\n    elif step == \"setSecret\":\n        set_secret(service_client, arn, token)\n    elif step == \"testSecret\":\n        test_secret(service_client, arn, token)\n    elif step == \"finishSecret\":\n        finish_secret(service_client, arn, token)\n    else:\n        raise ValueError(\"Invalid step: \" + step)\n\n    return {\"statusCode\": 200}\n\ndef create_secret(service_client, arn, token):\n    # Generate new secret value\n    new_password = generate_password()\n\n    # Get current secret\n    current = service_client.get_secret_value(SecretId=arn, VersionStage=\"AWSCURRENT\")\n    secret_dict = json.loads(current['SecretString'])\n\n    # Update with new password\n    secret_dict['password'] = new_password\n\n    # Store new secret\n    service_client.put_secret_value(\n        SecretId=arn,\n        ClientRequestToken=token,\n        SecretString=json.dumps(secret_dict),\n        VersionStages=['AWSPENDING']\n    )\n\ndef generate_password():\n    # Implement secure password generation\n    import string\n    import random\n    chars = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choice(chars) for _ in range(32))\n",
        "rotation_schedule": {
          "automatically_after_days": 30,
          "rotation_rules": {
            "database_credentials": 30,
            "api_keys": 90,
            "tls_certificates": 365
          }
        }
      },
      "encryption": {
        "kms_key_alias": "alias/Portfolio-secrets",
        "enable_automatic_rotation": true,
        "rotation_interval_days": 30
      }
    },
    "terraform_config": "\n# AWS Secrets Manager Configuration for Portfolio\n# Generated by James-OS GuidePoint Security Platform\n\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\n# KMS key for encryption\nresource \"aws_kms_key\" \"secrets_key\" {\n  description             = \"KMS key for Portfolio secrets\"\n  deletion_window_in_days = 10\n  enable_key_rotation     = true\n\n  tags = {\n    Project = \"Portfolio\"\n    Purpose = \"secrets-encryption\"\n  }\n}\n\nresource \"aws_kms_alias\" \"secrets_key_alias\" {\n  name          = \"alias/Portfolio-secrets\"\n  target_key_id = aws_kms_key.secrets_key.key_id\n}\n\n# Database credentials secret\nresource \"aws_secretsmanager_secret\" \"database_credentials\" {\n  name        = \"Portfolio/database/credentials\"\n  description = \"Database credentials for Portfolio\"\n  kms_key_id  = aws_kms_key.secrets_key.id\n\n  rotation_rules {\n    automatically_after_days = 30\n  }\n\n  tags = {\n    Project  = \"Portfolio\"\n    Type     = \"database\"\n    Rotation = \"enabled\"\n  }\n}\n\nresource \"aws_secretsmanager_secret_version\" \"database_credentials\" {\n  secret_id = aws_secretsmanager_secret.database_credentials.id\n  secret_string = jsonencode({\n    username = \"admin\"\n    password = \"CHANGE_ME_IMMEDIATELY\"\n    host     = \"database.internal\"\n    port     = 5432\n    database = \"Portfolio\"\n  })\n\n  lifecycle {\n    ignore_changes = [secret_string]\n  }\n}\n\n# API keys secret\nresource \"aws_secretsmanager_secret\" \"api_keys\" {\n  name        = \"Portfolio/api/keys\"\n  description = \"API keys for Portfolio\"\n  kms_key_id  = aws_kms_key.secrets_key.id\n\n  rotation_rules {\n    automatically_after_days = 90\n  }\n\n  tags = {\n    Project  = \"Portfolio\"\n    Type     = \"api\"\n    Rotation = \"enabled\"\n  }\n}\n\n# IAM role for application access\nresource \"aws_iam_role\" \"app_role\" {\n  name = \"Portfolio-app-role\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ec2.amazonaws.com\"\n        }\n      },\n      {\n        Action = \"sts:AssumeRoleWithWebIdentity\"\n        Effect = \"Allow\"\n        Principal = {\n          Federated = \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/${var.cluster_id}\"\n        }\n      }\n    ]\n  })\n}\n\n# IAM policy for reading secrets\nresource \"aws_iam_policy\" \"read_secrets\" {\n  name        = \"Portfolio-read-secrets\"\n  description = \"Policy to read Portfolio secrets\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"secretsmanager:GetSecretValue\",\n          \"secretsmanager:DescribeSecret\"\n        ]\n        Resource = \"arn:aws:secretsmanager:us-east-1:*:secret:Portfolio/*\"\n      },\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"kms:Decrypt\"\n        ]\n        Resource = aws_kms_key.secrets_key.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"app_read_secrets\" {\n  role       = aws_iam_role.app_role.name\n  policy_arn = aws_iam_policy.read_secrets.arn\n}\n\n# Output values for application configuration\noutput \"secrets_arns\" {\n  value = {\n    database = aws_secretsmanager_secret.database_credentials.arn\n    api_keys = aws_secretsmanager_secret.api_keys.arn\n  }\n  sensitive = true\n}\n",
    "kubernetes_integration": {
      "external_secrets_operator": "\n# Install External Secrets Operator\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: external-secrets\n\n---\n# ServiceAccount with IRSA\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: Portfolio-external-secrets-sa\n  namespace: Portfolio\n  annotations:\n    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT_ID:role/Portfolio-app-role\n\n---\n# SecretStore configuration\napiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\n  name: Portfolio-secret-store\n  namespace: Portfolio\nspec:\n  provider:\n    aws:\n      service: SecretsManager\n      region: us-east-1\n      auth:\n        jwt:\n          serviceAccountRef:\n            name: Portfolio-external-secrets-sa\n\n---\n# ExternalSecret to sync from AWS\napiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: Portfolio-database-secret\n  namespace: Portfolio\nspec:\n  refreshInterval: 1h\n  secretStoreRef:\n    name: Portfolio-secret-store\n    kind: SecretStore\n  target:\n    name: database-credentials\n    creationPolicy: Owner\n  data:\n  - secretKey: username\n    remoteRef:\n      key: Portfolio/database/credentials\n      property: username\n  - secretKey: password\n    remoteRef:\n      key: Portfolio/database/credentials\n      property: password\n",
      "secrets_csi_driver": "\n# AWS Secrets Manager CSI Driver configuration\napiVersion: v1\nkind: SecretProviderClass\nmetadata:\n  name: Portfolio-secrets-provider\n  namespace: Portfolio\nspec:\n  provider: aws\n  parameters:\n    objects: |\n      - objectName: \"Portfolio/database/credentials\"\n        objectType: \"secretsmanager\"\n        jmesPath:\n          - path: username\n            objectAlias: dbuser\n          - path: password\n            objectAlias: dbpass\n      - objectName: \"Portfolio/api/keys\"\n        objectType: \"secretsmanager\"\n\n---\n# Pod using CSI driver\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: Portfolio-app\n  namespace: Portfolio\nspec:\n  template:\n    spec:\n      serviceAccountName: Portfolio-external-secrets-sa\n      containers:\n      - name: app\n        image: Portfolio:latest\n        volumeMounts:\n        - name: secrets-store\n          mountPath: \"/mnt/secrets-store\"\n          readOnly: true\n      volumes:\n      - name: secrets-store\n        csi:\n          driver: secrets-store.csi.k8s.io\n          readOnly: true\n          volumeAttributes:\n            secretProviderClass: Portfolio-secrets-provider\n"
    }
  },
  "kubernetes": {
    "provider": "kubernetes",
    "project": "Portfolio",
    "timestamp": "2025-09-21T21:13:00.347006",
    "configuration": {
      "namespace": "Portfolio",
      "secrets": [
        {
          "name": "database-credentials",
          "manifest": "\napiVersion: v1\nkind: Secret\nmetadata:\n  name: Portfolio-db-secret\n  namespace: Portfolio\n  annotations:\n    kubernetes.io/description: \"Database credentials\"\n    rotation.secrets-manager.io/enabled: \"true\"\n    rotation.secrets-manager.io/rotation-period: \"30d\"\ntype: Opaque\nstringData:\n  username: admin\n  password: CHANGE_ME_IMMEDIATELY\n  host: postgres.Portfolio.svc.cluster.local\n  port: \"5432\"\n  database: Portfolio\n"
        },
        {
          "name": "tls-certificates",
          "manifest": "\napiVersion: v1\nkind: Secret\nmetadata:\n  name: Portfolio-tls\n  namespace: Portfolio\n  annotations:\n    kubernetes.io/description: \"TLS certificates\"\ntype: kubernetes.io/tls\ndata:\n  tls.crt: # base64 encoded certificate\n  tls.key: # base64 encoded private key\n"
        },
        {
          "name": "docker-registry",
          "manifest": "\napiVersion: v1\nkind: Secret\nmetadata:\n  name: Portfolio-registry\n  namespace: Portfolio\ntype: kubernetes.io/dockerconfigjson\ndata:\n  .dockerconfigjson: # base64 encoded docker config\n"
        }
      ],
      "rbac": {
        "role": "\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: Portfolio-secret-reader\n  namespace: Portfolio\nrules:\n- apiGroups: [\"\"]\n  resources: [\"secrets\"]\n  verbs: [\"get\", \"list\"]\n  resourceNames: [\"Portfolio-db-secret\", \"Portfolio-tls\"]\n",
        "rolebinding": "\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: Portfolio-secret-reader-binding\n  namespace: Portfolio\nsubjects:\n- kind: ServiceAccount\n  name: Portfolio-app\n  namespace: Portfolio\nroleRef:\n  kind: Role\n  name: Portfolio-secret-reader\n  apiGroup: rbac.authorization.k8s.io\n"
      },
      "sealed_secrets": {
        "installation": "\n# Install Sealed Secrets controller\nkubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.18.0/controller.yaml\n",
        "example": "\n# Seal a secret (run locally)\necho -n mypassword | kubectl create secret generic Portfolio-secret \\\n  --dry-run=client \\\n  --from-file=password=/dev/stdin \\\n  -o yaml | kubeseal -o yaml > sealed-secret.yaml\n\n---\n# Resulting SealedSecret (safe to commit to Git)\napiVersion: bitnami.com/v1alpha1\nkind: SealedSecret\nmetadata:\n  name: Portfolio-secret\n  namespace: Portfolio\nspec:\n  encryptedData:\n    password: AgXZO... # encrypted data\n  template:\n    metadata:\n      name: Portfolio-secret\n      namespace: Portfolio\n    type: Opaque\n"
      },
      "encryption": {
        "encryption_config": "\napiVersion: apiserver.config.k8s.io/v1\nkind: EncryptionConfiguration\nresources:\n  - resources:\n    - secrets\n    providers:\n    - aescbc:\n        keys:\n        - name: key1\n          secret: <base64-encoded-secret>\n    - identity: {}\n",
        "audit_policy": "\napiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n  - level: Metadata\n    omitStages:\n    - RequestReceived\n    resources:\n    - group: \"\"\n      resources: [\"secrets\"]\n    namespaces: [\"kube-system\", \"kube-public\"]\n  - level: RequestResponse\n    omitStages:\n    - RequestReceived\n    resources:\n    - group: \"\"\n      resources: [\"secrets\"]\n"
      }
    },
    "best_practices": [
      "Never commit plain secrets to Git - use Sealed Secrets or External Secrets Operator",
      "Enable encryption at rest for etcd",
      "Use RBAC to limit secret access to specific service accounts",
      "Rotate secrets regularly (at least every 90 days)",
      "Use separate secrets for different environments",
      "Mount secrets as volumes rather than environment variables when possible",
      "Enable audit logging for secret access",
      "Use admission controllers to enforce secret policies",
      "Consider using a secrets management solution (Vault, AWS SM) for production",
      "Implement secret scanning in CI/CD pipelines"
    ]
  }
}