# Spring Boot Vulnerability Remediation Guide

**Knowledge Type:** Security Remediation
**Category:** Dependency Management, CVE Fixes
**Tools:** Maven, Trivy, Spring Boot
**Last Updated:** 2025-10-07

## Problem Statement

When Trivy or other vulnerability scanners detect CRITICAL CVEs in Spring Boot applications, you need to upgrade dependencies while maintaining application compatibility.

## Common CVEs in Older Spring Boot Versions

### Spring Boot 2.5.x - 2.7.x (Java 11)
- **CVE-2025-24813** - Tomcat RCE vulnerability
- **CVE-2022-22965** - Spring4Shell RCE (critical)
- **CVE-2022-22978** - Spring Security authorization bypass
- **CVE-2024-38821** - Spring Security WebFlux bypass
- **CVE-2016-1000027** - Deserialization vulnerability
- **CVE-2023-20860** - Security bypass with double wildcard
- **CVE-2021-43466** - Thymeleaf template injection

## Solution: Version Upgrade Path

### Step 1: Identify Current Version

```bash
# Check pom.xml
grep -A2 "spring-boot-starter-parent" pom.xml
```

Example output:
```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.5.6</version>
</parent>
```

### Step 2: Choose Upgrade Strategy

**Option A: Stay on Spring Boot 2.7.x (Java 11)**
- Fixes most CVEs but not all
- Minimal breaking changes
- Upgrade path: `2.5.x → 2.7.18` (latest 2.7.x)
- Security support: Until November 2025

**Option B: Upgrade to Spring Boot 3.2.x (Java 17)** ⭐ RECOMMENDED
- Fixes ALL known CRITICAL CVEs
- Requires Java 17+
- Breaking changes: javax.* → jakarta.* namespace
- Upgrade path: `2.x → 3.2.11` (latest LTS)
- Security support: Until May 2026

### Step 3: Upgrade Spring Boot Version

**For Spring Boot 2.7.x (Minimal Changes):**

```xml
<!-- pom.xml -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.7.18</version>  <!-- Changed from 2.5.6 -->
</parent>
<properties>
    <java.version>11</java.version>  <!-- No change -->
</properties>
```

**For Spring Boot 3.2.x (Full Fix):**

```xml
<!-- pom.xml -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.2.11</version>  <!-- Changed from 2.x -->
</parent>
<properties>
    <java.version>17</java.version>  <!-- Changed from 11 -->
</properties>
```

### Step 4: Handle Breaking Changes (Spring Boot 3.x Only)

**Required: Migrate javax.* to jakarta.***

```bash
# Automated migration using sed
find src/main/java -name "*.java" -type f -exec sed -i 's/import javax\.servlet\./import jakarta.servlet./g' {} \;
find src/main/java -name "*.java" -type f -exec sed -i 's/import javax\.sql\./import jakarta.sql./g' {} \;
find src/main/java -name "*.java" -type f -exec sed -i 's/import javax\.persistence\./import jakarta.persistence./g' {} \;
find src/main/java -name "*.java" -type f -exec sed -i 's/import javax\.validation\./import jakarta.validation./g' {} \;
```

**Common Imports to Update:**
- `javax.servlet.*` → `jakarta.servlet.*`
- `javax.sql.*` → `jakarta.sql.*`
- `javax.persistence.*` → `jakarta.persistence.*`
- `javax.validation.*` → `jakarta.validation.*`

**Verify Migration:**
```bash
# Should return 0
grep -r "import javax\." src/main/java/ | wc -l

# Should show jakarta imports
grep -r "import jakarta\." src/main/java/ | head -5
```

### Step 5: Update Dockerfile

**For Spring Boot 2.7.x (Java 11):**
```dockerfile
FROM adoptopenjdk/openjdk11
# ... rest of Dockerfile
COPY target/your-app-0.0.5.jar app.jar
```

**For Spring Boot 3.2.x (Java 17):**
```dockerfile
FROM eclipse-temurin:17-jre-alpine
# ... rest of Dockerfile
COPY target/your-app-0.0.6.jar app.jar
```

### Step 6: Update Version Numbers

Update your application version in:
- `pom.xml` - `<version>0.0.6</version>`
- `Dockerfile` - JAR filename
- Any deployment manifests

### Step 7: Test the Build

```bash
# Clean build
mvn clean package

# Verify JAR was created
ls -lh target/*.jar

# Run Trivy scan
trivy fs . --severity CRITICAL

# Expected output: "Total: 0 (CRITICAL: 0)"
```

### Step 8: Commit Changes

```bash
git add pom.xml Dockerfile src/
git commit -m "Upgrade to Spring Boot 3.2.11 and Java 17 to fix CRITICAL CVEs

- Fix CVE-2025-24813, CVE-2024-38821, CVE-2016-1000027
- Migrate javax.* to jakarta.* namespace
- Update to Java 17 LTS"
git push origin main
```

## Verification

### Check for Remaining Vulnerabilities

```bash
# Trivy filesystem scan
trivy fs . --severity CRITICAL --exit-code 1

# Trivy on built JAR
trivy archive target/*.jar --severity CRITICAL
```

**Expected output:**
```
Total: 0 (CRITICAL: 0)
```

### Test Application Startup

```bash
java -jar target/database_service_project-0.0.6.jar
```

Check logs for:
- ✅ No errors on startup
- ✅ Application context loads
- ✅ Database connections work
- ✅ Security configuration applied

## Common Issues and Solutions

### Issue 1: "package javax.servlet does not exist"

**Cause:** Spring Boot 3.x uses jakarta.* namespace  
**Solution:** Run the sed migration script (Step 4)

### Issue 2: "Unsupported class file major version 61"

**Cause:** Java 17 bytecode can't run on Java 11  
**Solution:** Update all environments to Java 17+

### Issue 3: Build fails with dependency conflicts

**Cause:** Some dependencies may not be compatible with Spring Boot 3.x  
**Solution:** 
```bash
# Check for outdated dependencies
mvn versions:display-dependency-updates

# Update incompatible dependencies manually
```

### Issue 4: Thymeleaf templates broken

**Cause:** Thymeleaf 3.1+ changed some syntax  
**Solution:** Check templates for deprecated attributes:
- `th:field` on non-form elements
- Inline expressions without proper escaping

## Decision Matrix

| Scenario | Recommended Action | Reason |
|----------|-------------------|---------|
| Production app on Java 11 | Upgrade to 2.7.18 first, plan 3.x migration | Reduces risk, fixes most CVEs |
| New development | Start with 3.2.x + Java 17 | Modern stack, full security |
| Legacy app with complex dependencies | Stay on 2.7.18, monitor CVEs | Breaking changes too risky |
| Portfolio/demo project | Upgrade to 3.2.x | Shows modern skills |

## Success Criteria

- ✅ Trivy scan shows 0 CRITICAL vulnerabilities
- ✅ Application builds successfully (`mvn package`)
- ✅ Application starts without errors
- ✅ All unit tests pass
- ✅ Integration tests pass
- ✅ CI/CD pipeline passes

## References

- [Spring Boot 2.7 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.7-Release-Notes)
- [Spring Boot 3.0 Migration Guide](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide)
- [Jakarta EE Migration](https://jakarta.ee/specifications/platform/9/jakarta-platform-spec-9.0.html)
- [Trivy Documentation](https://aquasecurity.github.io/trivy/)

## Real-World Example

**Project:** CLOUD-project (Spring Boot Board Game App)

**Initial State:**
- Spring Boot 2.5.6
- Java 11
- 10 CRITICAL CVEs

**Actions Taken:**
1. Attempted upgrade to 2.7.18 → Reduced to 3 CRITICAL CVEs
2. Upgraded to 3.2.11 + Java 17 → 0 CRITICAL CVEs
3. Migrated javax.* → jakarta.*
4. Updated Dockerfile to eclipse-temurin:17-jre-alpine
5. Verified with Trivy

**Final State:**
- Spring Boot 3.2.11
- Java 17
- 0 CRITICAL CVEs
- Production-ready security posture

**Files Changed:**
- `pom.xml` - Version updates
- `Dockerfile` - Base image + JAR name
- `src/main/java/**/*.java` - Import statements
- Version number bumped 0.0.4 → 0.0.6

**Time to Complete:** ~15 minutes  
**Breaking Changes:** Minimal (only import statements)

---

## Additional Breaking Changes for Spring Boot 3.x

### Thymeleaf Security Extras

Spring Boot 3.x uses Spring Security 6, which requires thymeleaf-extras-springsecurity**6**.

**Error:**
```
'dependencies.dependency.version' for org.thymeleaf.extras:thymeleaf-extras-springsecurity5:jar is missing.
```

**Fix in pom.xml:**
```xml
<!-- OLD (Spring Boot 2.x) -->
<dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-springsecurity5</artifactId>
</dependency>

<!-- NEW (Spring Boot 3.x) -->
<dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-springsecurity6</artifactId>
</dependency>
```

## Complete Checklist for Spring Boot 3.x Migration

- [ ] Update `spring-boot-starter-parent` to 3.2.11
- [ ] Update `<java.version>` to 17
- [ ] Migrate `javax.*` → `jakarta.*` imports
- [ ] Change `thymeleaf-extras-springsecurity5` → `springsecurity6`
- [ ] Update Dockerfile base image to Java 17
- [ ] Update JAR filename in Dockerfile
- [ ] Bump application version number
- [ ] Run `mvn clean package` to verify build
- [ ] Run `trivy fs .` to verify 0 CRITICAL CVEs
- [ ] Test application startup
- [ ] Commit and push changes

---

## Spring Security 6 Migration (Critical for Spring Boot 3.x)

### WebSecurityConfigurerAdapter Removed

Spring Boot 3.x uses Spring Security 6, which **removed** `WebSecurityConfigurerAdapter`.

**Error:**
```
cannot find symbol
  symbol: class WebSecurityConfigurerAdapter
```

### Migration Steps

**OLD Pattern (Spring Security 5.x):**
```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .antMatchers("/user/**").hasAnyRole("USER", "MANAGER")
            .antMatchers("/", "/**").permitAll()
            .and()
            .formLogin().loginPage("/login")
            .and()
            .logout();
        
        http.csrf().disable();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.jdbcAuthentication()
            .dataSource(dataSource)
            .withUser("admin").password(encoder.encode("pass")).roles("ADMIN");
    }
}
```

**NEW Pattern (Spring Security 6.x):**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/user/**").hasAnyRole("USER", "MANAGER")
                .requestMatchers("/", "/**").permitAll()
            )
            .formLogin(form -> form
                .loginPage("/login")
                .permitAll()
            )
            .logout(logout -> logout
                .permitAll()
            )
            .csrf(csrf -> csrf.disable());
        
        return http.build();
    }

    @Bean
    public JdbcUserDetailsManager jdbcUserDetailsManager(DataSource dataSource, 
                                                         PasswordEncoder encoder) {
        JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);
        
        manager.createUser(
            User.withUsername("admin")
                .password(encoder.encode("pass"))
                .roles("ADMIN")
                .build()
        );
        
        return manager;
    }
}
```

### Key Changes Summary

| Old (Spring Security 5) | New (Spring Security 6) |
|------------------------|-------------------------|
| `extends WebSecurityConfigurerAdapter` | Use `@Bean SecurityFilterChain` |
| `configure(HttpSecurity http)` | `SecurityFilterChain filterChain(HttpSecurity http)` |
| `authorizeRequests()` | `authorizeHttpRequests()` |
| `antMatchers()` | `requestMatchers()` |
| `.and()` chaining | Lambda DSL |
| `configure(AuthenticationManagerBuilder)` | `@Bean JdbcUserDetailsManager` |
| Return void | Return `http.build()` |

### Full Example with All Features

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private DataSource dataSource;
    
    @Autowired
    private LoggingAccessDeniedHandler accessDeniedHandler;

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")
                .requestMatchers("/public/**", "/").permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/login")
                .defaultSuccessUrl("/dashboard")
                .failureUrl("/login?error=true")
                .permitAll()
            )
            .logout(logout -> logout
                .logoutUrl("/logout")
                .logoutSuccessUrl("/")
                .invalidateHttpSession(true)
                .clearAuthentication(true)
                .deleteCookies("JSESSIONID")
                .permitAll()
            )
            .exceptionHandling(ex -> ex
                .accessDeniedHandler(accessDeniedHandler)
                .accessDeniedPage("/access-denied")
            )
            .sessionManagement(session -> session
                .maximumSessions(1)
                .maxSessionsPreventsLogin(true)
            )
            .csrf(csrf -> csrf.disable())
            .headers(headers -> headers
                .frameOptions(frame -> frame.sameOrigin())
            );

        return http.build();
    }

    @Bean
    public JdbcUserDetailsManager jdbcUserDetailsManager(
            DataSource dataSource,
            PasswordEncoder passwordEncoder) throws Exception {
        
        JdbcUserDetailsManager manager = new JdbcUserDetailsManager();
        manager.setDataSource(dataSource);
        
        // Create default users
        manager.createUser(
            User.withUsername("user")
                .password(passwordEncoder.encode("password"))
                .roles("USER")
                .build()
        );
        
        manager.createUser(
            User.withUsername("admin")
                .password(passwordEncoder.encode("admin"))
                .roles("USER", "ADMIN")
                .build()
        );
        
        return manager;
    }
}
```

### Testing After Migration

```bash
# Build should succeed
mvn clean compile

# Check for compilation errors
mvn clean package

# Look for these patterns in logs:
# ✅ "Will secure any request with..."
# ✅ "Creating filter chain..."
# ❌ No "WebSecurityConfigurerAdapter" mentions
```

### Common Migration Errors

**Error 1:** `cannot find symbol: method antMatchers`
**Fix:** Change to `requestMatchers()`

**Error 2:** `The method authorizeRequests() is undefined`
**Fix:** Change to `authorizeHttpRequests()`

**Error 3:** `cannot convert from HttpSecurity to SecurityFilterChain`
**Fix:** Add `return http.build();` at end

**Error 4:** Users not created
**Fix:** Move user creation from `configure()` to `@Bean JdbcUserDetailsManager`

## Updated Complete Checklist

- [ ] Update `spring-boot-starter-parent` to 3.2.11
- [ ] Update `<java.version>` to 17  
- [ ] Migrate `javax.*` → `jakarta.*` imports
- [ ] Change `thymeleaf-extras-springsecurity5` → `springsecurity6`
- [ ] **Remove `WebSecurityConfigurerAdapter` extension**
- [ ] **Create `SecurityFilterChain` bean**
- [ ] **Change `antMatchers` → `requestMatchers`**
- [ ] **Change `authorizeRequests` → `authorizeHttpRequests`**
- [ ] **Use lambda DSL instead of `.and()` chaining**
- [ ] **Add `@Configuration` annotation**
- [ ] Update Dockerfile base image to Java 17
- [ ] Update JAR filename in Dockerfile
- [ ] Bump application version number
- [ ] Run `mvn clean package` to verify build
- [ ] Run `trivy fs .` to verify 0 CRITICAL CVEs
- [ ] Test application startup
- [ ] Test authentication still works
- [ ] Commit and push changes

---

## CRITICAL: javax.sql.DataSource Does NOT Change!

### Common Mistake

**❌ WRONG:**
```java
import jakarta.sql.DataSource;  // Does not exist!
```

**✅ CORRECT:**
```java
import javax.sql.DataSource;  // Still javax (Java SE)
```

### Why?

**javax.sql** is part of **Java SE**, not Jakarta EE. Only Jakarta EE APIs changed from javax → jakarta.

### Updated Migration Script (CORRECTED)

```bash
# Migrate Jakarta EE packages ONLY (NOT javax.sql)
find src/main/java -name "*.java" -type f -exec sed -i 's/import javax\.servlet\./import jakarta.servlet./g' {} \;
find src/main/java -name "*.java" -type f -exec sed -i 's/import javax\.persistence\./import jakarta.persistence./g' {} \;
find src/main/java -name "*.java" -type f -exec sed -i 's/import javax\.validation\./import jakarta.validation./g' {} \;

# DO NOT CHANGE javax.sql - it stays as javax!
```

### Package Migration Reference

| Package | Migrates? | New Package |
|---------|-----------|-------------|
| `javax.servlet.*` | ✅ YES | `jakarta.servlet.*` |
| `javax.persistence.*` | ✅ YES | `jakarta.persistence.*` |
| `javax.validation.*` | ✅ YES | `jakarta.validation.*` |
| `javax.annotation.*` | ✅ YES | `jakarta.annotation.*` |
| `javax.transaction.*` | ✅ YES | `jakarta.transaction.*` |
| `javax.sql.*` | ❌ NO | Stays `javax.sql.*` (Java SE) |
| `javax.xml.*` | ❌ NO | Stays `javax.xml.*` (Java SE) |
| `javax.crypto.*` | ❌ NO | Stays `javax.crypto.*` (Java SE) |
| `javax.net.*` | ❌ NO | Stays `javax.net.*` (Java SE) |

### Rule of Thumb

- **Jakarta EE APIs** (servlet, JPA, validation) → Change to `jakarta.*`
- **Java SE APIs** (sql, xml, crypto, net) → Keep as `javax.*`

If you accidentally change `javax.sql` to `jakarta.sql`, you'll get:
```
package jakarta.sql does not exist
cannot find symbol: class DataSource
```

**Fix:** Revert to `javax.sql.DataSource`
